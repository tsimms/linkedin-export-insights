<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>LinkedIn Analytics</title>

  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script type="text/javascript" src="./jszip.js"></script>
  <script type="text/javascript" src="./data.js"></script>
  <style type="text/css">
    #chart { display: none; height:80% !important; width:80% !important; margin:auto; }
  </style>
</head>
<body>

  <form>
    <div>
      What granularity do you want to inspect? <select id="granularity">
        <option>yearly</option>
        <option selected>monthly</option>
        <option>weekly</option>
      </select>  
    </div>
    <div>
      Do you want to ignore group posts? <select id="ignoreGroupPosts">
        <option>yes</option>
        <option>no</option>
      </select>
    </div>
    <div>
      <input id="filesInput" type="file" onchange="onFileSelected()" />
    </div>

  </form>

  <div>
    <canvas id="chart"></canvas>
  </div>

  <script type="text/javascript">
    let granularity, ignoreGroupPosts;
    const getMonthCutoff = () => {
      const monthCutoff = new Date();
      monthCutoff.setMonth(monthCutoff.getMonth() - 13);
      const cutoffKey = `${monthCutoff.getFullYear()}-${String(monthCutoff.getMonth() + 1).padStart(2, '0')}`;
      return cutoffKey;
    }
    const getWeekCutoff = () => {
      const weekCutoff = new Date();
      weekCutoff.setDate(weekCutoff.getDate() - 7*16);
      const cutoffKey = `${weekCutoff.getFullYear()}W${String(Math.ceil((weekCutoff - new Date(weekCutoff.getFullYear(), 0, 1)) / 86400000 / 7)).padStart(2,'0')}`;
      return cutoffKey;
    }
    const filterKeys = (granularity, data) => {
      let dataset = data;
      switch (granularity) {
        case "yearly":
          break;
        case "monthly":
          dataset = data.filter(d => (d.length === 7 && d >= getMonthCutoff()))
          break;
        case "weekly":
          dataset = data.filter(d => (d.length === 7 && d >= getWeekCutoff()))
          break;
      }
      return dataset;
    }
    const setChart = (data) => {
      let labels = [];

      Object.keys(data).forEach(key => Object.keys(data[key])
        // TODO: probably just want to iterate to set labels whether there's data or not
        //.filter(d => (granularity === "yearly" || (d.length === 7 && d >= monthFilterCutoff)))
        .forEach(key => {
          if (!labels.includes(key)) labels.push(key); })
      );
      labels = filterKeys(granularity, labels);
      if (granularity === "yearly")
        labels = labels.filter(year => year >= 2000).sort()
      const chartOptions = {
        interaction: {
          intersect: false,
          mode: 'index'
        }
      };
      const chartData = { 
        labels,
        datasets: [
          {
            label: "Sent Messages",
            data: filterKeys(granularity, Object.keys(data.SentMessages))
              //.filter(k => (granularity==="yearly" || granularity==="monthly" && k >= monthFilterCutoff))
              .sort((a, b) => b.localeCompare(a))
              .map(x => ({ x, y:data.SentMessages[x].length }))
          },
          {
            label: "Connections",
            data: filterKeys(granularity, Object.keys(data.Connections))
              //.filter(k => (granularity==="yearly" || granularity==="monthly" && k >= monthFilterCutoff))
              .map(x => ({ x, y:data.Connections[x].length }))
          },
          {
            label: "Comments",
            data: filterKeys(granularity, data.Comments ? Object.keys(data.Comments) : [])
              //.filter(k => (granularity==="yearly" || granularity==="monthly" && k >= monthFilterCutoff))
              .map(x => ({ x, y:data.Comments[x].length }))
          },
          {
            label: "Posts",
            data: filterKeys(granularity, data.Shares ? Object.keys(data.Shares) : [])
              //.filter(k => (granularity==="yearly" || granularity==="monthly" && k >= monthFilterCutoff))
              .map(x => ({ x, y:data.Shares[x]
                .filter(p => (!ignoreGroupPosts || !p.sharelink.match(/group/)))
                .length }))
          },
          {
            label: "Reactions",
            data: filterKeys(granularity, Object.keys(data.Reactions))
              //.filter(k => (granularity==="yearly" || granularity==="monthly" && k >= monthFilterCutoff))
              .map(x => ({
                x,
                y:data.Reactions[x].length-1,
                meta:{
                  types: Object.keys(data.Reactions[x].types).map(
                    type => ({ [type]: data.Reactions[x].types[type].length })
                  )
                }
              }))
          },
          {
            label: "Votes",
            data: filterKeys(granularity, Object.keys(data.Votes))
              //.filter(k => (granularity==="yearly" || granularity==="monthly" && k >= monthFilterCutoff))
              .map(x => ({ x, y:data.Votes[x].length }))
          }
        ]
      };
      console.log({ data, chartData });
      DATA = data;
      const ctx = document.getElementById('chart');
      new Chart(ctx, {
        type: 'line',
        data: chartData,
        options: chartOptions
      });
      ctx.style.display = 'block';
    };

    const onFileSelected = () => {
      granularity = document.getElementById('granularity').value;
      ignoreGroupPosts = document.getElementById('ignoreGroupPosts').value === "yes";
      const files = filesInput.files;
      if (files.length) {
        readZip(files[0], granularity)
          .then(transformFinal)
          .then(setChart);
      }
    };
  </script>

</body>
</html>
