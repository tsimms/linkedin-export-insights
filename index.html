<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>LinkedIn Analytics</title>

  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script type="text/javascript" src="./jszip.js"></script>
  <script type="text/javascript" src="./data.js"></script>
  <style type="text/css">
    #chart { display: none; height:80% !important; width:80% !important; margin:auto; }
    #analytics {
      margin: 0 auto;
      display: flex;
      justify-content: center;
    }
    .hcard {
      margin: 20px;
      border: 1px solid #ccc;
      padding: 10px;
      font-family: monospace;
      border-radius: 5px;
      background-color: #bbb;
    }
    .hcard.projection-above-avg {
      background-color: #bdb
    }
  </style>
</head>
<body>

  <form>
    <div>
      What granularity do you want to inspect? <select id="granularity" onchange="processFile();">
        <option>yearly</option>
        <option selected>monthly</option>
        <option>weekly</option>
      </select>  
    </div>
    <div>
      Do you want to ignore group posts? <select id="ignoreGroupPosts" onchange="processFile();">
        <option>yes</option>
        <option>no</option>
      </select>
    </div>
    <div>
      <input id="filesInput" type="file" onchange="onFileSelected()" />
    </div>

  </form>

  <div>
    <canvas id="chart"></canvas>
  </div>
  <div id="analytics">

  </div>

  <script type="text/javascript">
    let granularity, ignoreGroupPosts;
    let chart, chartData, uploadedFile;
    const getMonthCutoff = () => {
      const monthCutoff = new Date();
      monthCutoff.setMonth(monthCutoff.getMonth() - 13);
      const cutoffKey = `${monthCutoff.getFullYear()}-${String(monthCutoff.getMonth() + 1).padStart(2, '0')}`;
      return cutoffKey;
    }
    const getWeekCutoff = () => {
      const weekCutoff = new Date();
      weekCutoff.setDate(weekCutoff.getDate() - 7*16);
      const cutoffKey = `${weekCutoff.getFullYear()}W${String(Math.ceil((weekCutoff - new Date(weekCutoff.getFullYear(), 0, 1)) / 86400000 / 7)).padStart(2,'0')}`;
      return cutoffKey;
    }
    const filterKeys = (granularity, data) => {
      let dataset = data;
      switch (granularity) {
        case "yearly":
          break;
        case "monthly":
          dataset = data.filter(d => (d.length === 7 && d >= getMonthCutoff()))
          break;
        case "weekly":
          dataset = data.filter(d => (d.length === 7 && d >= getWeekCutoff()))
          break;
      }
      return dataset;
    }
    const setChart = (data) => {
      let labels = [];

      Object.keys(data).forEach(key => Object.keys(data[key])
        // TODO: probably just want to iterate to set labels whether there's data or not
        .forEach(key => {
          if (!labels.includes(key)) labels.push(key); })
      );
      labels = filterKeys(granularity, labels);
      if (granularity === "yearly")
        labels = labels.filter(year => year >= 2000).sort((a,b) => (b-a))
      const chartOptions = {
        interaction: {
          intersect: false,
          mode: 'index'
        }
      };
      chartData = { 
        labels,
        datasets: [
          {
            label: "Sent Messages",
            data: filterKeys(granularity, Object.keys(data.SentMessages))
              .sort((a, b) => b.localeCompare(a))
              .map(x => ({ 
                x,
                y:data.SentMessages[x].length,
                span:(new Date(data.SentMessages[x][0].date) - new Date(data.SentMessages[x][data.SentMessages[x].length-1].date))
             }))
          },
          {
            label: "Connections",
            data: filterKeys(granularity, Object.keys(data.Connections))
              .sort((a, b) => b.localeCompare(a))
              .map(x => ({
                x,
                y:data.Connections[x].length,
                span:(new Date(data.Connections[x][0].date) - new Date(data.Connections[x][data.Connections[x].length-1].date))
              }))
          },
          {
            label: "Comments",
            data: filterKeys(granularity, data.Comments ? Object.keys(data.Comments) : [])
              .sort((a, b) => b.localeCompare(a))
              .map(x => ({
                x,
                y:data.Comments[x].length,
                span:(new Date(data.Comments[x][0].date) - new Date(data.Comments[x][data.Comments[x].length-1].date))
              }))
          },
          {
            label: "Posts",
            data: filterKeys(granularity, data.Shares ? Object.keys(data.Shares) : [])
              .sort((a, b) => b.localeCompare(a))
              .map(x => ({
                x,
                y:data.Shares[x].filter(p => (!ignoreGroupPosts || !p.sharelink.match(/group/))).length,
                span: data.Shares[x].filter(p => (!ignoreGroupPosts || !p.sharelink.match(/group/))).length ? (
                  new Date(data.Shares[x].filter(p => (!ignoreGroupPosts || !p.sharelink.match(/group/)))[0].date)
                    - new Date(data.Shares[x].filter(p => (!ignoreGroupPosts || !p.sharelink.match(/group/)))
                      [data.Shares[x].filter(p => (!ignoreGroupPosts || !p.sharelink.match(/group/))).length-1].date)
                ) : 0
              }))
          },
          {
            label: "Reactions",
            data: filterKeys(granularity, Object.keys(data.Reactions))
              .sort((a, b) => b.localeCompare(a))
              .map(x => ({
                x,
                y:data.Reactions[x].length-1,
                span:(new Date(data.Reactions[x][0].date) - new Date(data.Reactions[x][data.Reactions[x].length-1].date)),
                meta:{
                  types: Object.keys(data.Reactions[x].types).map(
                    type => ({ [type]: data.Reactions[x].types[type].length })
                  )
                }
              }))
          },
          {
            label: "Votes",
            data: filterKeys(granularity, Object.keys(data.Votes))
              .sort((a, b) => b.localeCompare(a))
              .map(x => ({
                x,
                y:data.Votes[x].length,
                span:(new Date(data.Votes[x][0].date) - new Date(data.Votes[x][data.Votes[x].length-1].date))
              }))
          }
        ]
      };
      console.log({ data, chartData });
      DATA = data;
      const ctx = document.getElementById('chart');
      chart = new Chart(ctx, {
        type: 'line',
        data: chartData,
        options: chartOptions
      });
      ctx.style.display = 'block';
      showAnalytics();
      //document.getElementById('recalculate').style.display = 'block';
    };

    const analyticsCalc = (dataset) => {
      const mean = (dataset.reduce((a,b)=>(a+b.y),0)/dataset.length).toFixed(1);
      const current = dataset[0].y;
      const dataset_past = dataset.slice(1);
      const dataset_now = dataset[0];
      const past_span_avg = (dataset_past.reduce((a,b)=>(a+b.span),0)/dataset_past.length / 86400000).toFixed(1);
      const current_span = (dataset_now.span / 86400000).toFixed(1);
      const elapsed = (current_span / past_span_avg).toFixed(3);
      const projected = elapsed !== '0.000' ? (current / elapsed).toFixed(1) : "0";
      const projectionAboveAvg = (parseFloat(projected) >= parseFloat(mean));
      return { mean, current, elapsed, projected, projectionAboveAvg };
    };

    const showAnalytics = () => {
      document.getElementById('analytics').innerHTML =
        chartData.datasets.map(ds => ({
        ...analyticsCalc(ds.data),
        label:ds.label
      }))
        .map(d => (`
        <div class="hcard${d.projectionAboveAvg ? ' projection-above-avg':''}">
        <div class="label">${d.label}</div>
        <div class="mean"><label>Avg:</label><span class="value">${d.mean}</span></div>
        <div class="projected"><label>Proj:</label><span class="value">${d.projected}</span></div>
        </div>
        `))
        .join(" ")
    }

    const onFileSelected = () => {
      const files = filesInput.files;
      if (files.length) {
        uploadedFile = files[0];
        processFile();
      }
    };

    const processFile = () => {
      granularity = document.getElementById('granularity').value;
      ignoreGroupPosts = document.getElementById('ignoreGroupPosts').value === "yes";
      if (chart) {
        chart.destroy();
      }
      if (uploadedFile) {
        readZip(uploadedFile, granularity)
          .then(transformFinal)
          .then(setChart);
      }
    };
  </script>

</body>
</html>
