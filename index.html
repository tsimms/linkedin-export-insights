<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>LinkedIn Analytics</title>

  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script type="text/javascript" src="./jszip.js"></script>
  <script type="text/javascript" src="./data.js"></script>
  <script type="text/javascript">
  </script>
  <style type="text/css">
    body { font-family: "Real Text Pro", "Helvetica Neue", Arial, sans-serif; color: #222; }
    #chart { display: none; height:80% !important; width:80% !important; margin:auto; }
    #range { float: right; font-family:Arial, Helvetica, sans-serif; margin-right: 12%; color: #777; }
    #analytics {
      margin: 0 auto;
      display: flex;
      justify-content: center;
    }
    .hcard {
      margin: 20px;
      border: 1px solid #bbb;
      padding: 10px;
      font-family: monospace;
      border-radius: 5px;
      background-color: #ccc;
    }
    .hcard.projection-above-avg { background-color: #eec }
    .hcard.current-above-avg { background-color: #cfc }
    .hcard.projection-above-goal { background-color: #cfc }
    .hcard.current-above-goal { background-color: #287128; color: #fff; }
    .hcard .label {
      margin: 5px 0;
      font-size: 1.2em;
    }
    .hcard label {
      font-size: 0.7em;
      margin: 0 5px 0 0;
    }
  </style>
</head>
<body>

  <form>
    <div>
      What granularity do you want to inspect? <select id="granularity" onchange="uxOptions();">
        <option>yearly</option>
        <option selected>monthly</option>
        <option>weekly</option>
      </select>  
    </div>
    <div>
      Do you want to ignore group posts? <select id="ignoreGroupPosts" onchange="uxOptions();">
        <option>yes</option>
        <option>no</option>
      </select>
    </div>
    <div>
      <input id="filesInput" type="file" onchange="onFileSelected()" />
    </div>
  </form>

  <div>
    <div id="range"></div>
    <canvas id="chart"></canvas>
  </div>
  <div id="analytics">
  </div>

  <script type="text/javascript">
    let _data, _chart, _chartData, _settings, _uploadedFile;

    ////////
    // Data preparation routines
    ////////
    const getMonthCutoff = () => {
      const monthCutoff = new Date();
      monthCutoff.setMonth(monthCutoff.getMonth() - 13);
      const cutoffKey = `${monthCutoff.getFullYear()}-${String(monthCutoff.getMonth() + 1).padStart(2, '0')}`;
      return cutoffKey;
    }
    const getWeekCutoff = () => {
      const weekCutoff = new Date();
      weekCutoff.setDate(weekCutoff.getDate() - 7*16);
      const cutoffKey = `${weekCutoff.getFullYear()}W${String(Math.ceil((weekCutoff - new Date(weekCutoff.getFullYear(), 0, 1)) / 86400000 / 7)).padStart(2,'0')}`;
      return cutoffKey;
    }
    const filterKeys = (granularity, data) => {
      let dataset = data;
      switch (granularity) {
        case "yearly":
          break;
        case "monthly":
          dataset = data.filter(d => (d.length === 7 && d >= getMonthCutoff()))
          break;
        case "weekly":
          dataset = data.filter(d => (d.length === 7 && d >= getWeekCutoff()))
          break;
      }
      return dataset;
    }

    const setChart = (data) => {
      let labels = [];
      const { granularity, ignoreGroupPosts } = _settings.options;

      Object.keys(data).forEach(key => Object.keys(data[key])
        // TODO: probably just want to iterate to set labels whether there's data or not
        .forEach(labelKey => {
          if (!labels.includes(labelKey)) labels.push(labelKey);
        })
      );
      labels = filterKeys(granularity, labels);
      if (granularity === "yearly")
        labels = labels.filter(year => year >= 2000).sort((a,b) => (b-a))
      const chartOptions = {
        interaction: {
          intersect: false,
          mode: 'index'
        }
      };
      _chartData = { 
        labels,
        datasets: [
          {
            label: "Sent Messages",
            data: filterKeys(granularity, Object.keys(data.SentMessages))
              .sort((a, b) => b.localeCompare(a))
              .map(x => ({ 
                x,
                y:data.SentMessages[x].length,
                span:(new Date(data.SentMessages[x][0].date) - new Date(data.SentMessages[x][data.SentMessages[x].length-1].date)),
                first:new Date(data.SentMessages[x][0].date),
                last:new Date(data.SentMessages[x][data.SentMessages[x].length-1].date)
             }))
          },
          {
            label: "Connections",
            data: filterKeys(granularity, Object.keys(data.Connections))
              .sort((a, b) => b.localeCompare(a))
              .map(x => ({
                x,
                y:data.Connections[x].length,
                span:(new Date(data.Connections[x][0].date) - new Date(data.Connections[x][data.Connections[x].length-1].date)),
                first:new Date(data.Connections[x][0].date),
                last:new Date(data.Connections[x][data.Connections[x].length-1].date)
              }))
          },
          {
            label: "Comments",
            data: filterKeys(granularity, data.Comments ? Object.keys(data.Comments) : [])
              .sort((a, b) => b.localeCompare(a))
              .map(x => ({
                x,
                y:data.Comments[x].length,
                span:(new Date(data.Comments[x][0].date) - new Date(data.Comments[x][data.Comments[x].length-1].date)),
                first:new Date(data.Comments[x][0].date),
                last:new Date(data.Comments[x][data.Comments[x].length-1].date)
              }))
          },
          {
            label: "Posts",
            data: filterKeys(granularity, data.Shares ? Object.keys(data.Shares) : [])
              .sort((a, b) => b.localeCompare(a))
              .map(x => ({
                x,
                y:data.Shares[x].filter(p => (!ignoreGroupPosts || !p.sharelink.match(/group/))).length,
                span: data.Shares[x].filter(p => (!ignoreGroupPosts || !p.sharelink.match(/group/))).length ? (
                  new Date(data.Shares[x].filter(p => (!ignoreGroupPosts || !p.sharelink.match(/group/)))[0].date)
                    - new Date(data.Shares[x].filter(p => (!ignoreGroupPosts || !p.sharelink.match(/group/)))
                      [data.Shares[x].filter(p => (!ignoreGroupPosts || !p.sharelink.match(/group/))).length-1].date)
                ) : 0,
                first:new Date(data.Shares[x][0].date),
                last:new Date(data.Shares[x][data.Shares[x].length-1].date)
              }))
          },
          {
            label: "Reactions",
            data: filterKeys(granularity, Object.keys(data.Reactions))
              .sort((a, b) => b.localeCompare(a))
              .map(x => ({
                x,
                y:data.Reactions[x].length-1,
                span:(new Date(data.Reactions[x][0].date) - new Date(data.Reactions[x][data.Reactions[x].length-1].date)),
                first:new Date(data.Reactions[x][0].date),
                last:new Date(data.Reactions[x][data.Reactions[x].length-1].date),
                meta:{
                  types: Object.keys(data.Reactions[x].types).map(
                    type => ({ [type]: data.Reactions[x].types[type].length })
                  )
                }
              }))
          },
          {
            label: "Votes",
            data: filterKeys(granularity, Object.keys(data.Votes))
              .sort((a, b) => b.localeCompare(a))
              .map(x => ({
                x,
                y:data.Votes[x].length,
                span:(new Date(data.Votes[x][0].date) - new Date(data.Votes[x][data.Votes[x].length-1].date)),
                first:new Date(data.Votes[x][0].date),
                last:new Date(data.Votes[x][data.Votes[x].length-1].date)
              }))
          }
        ]
      };
      _data = data;
      const ctx = document.getElementById('chart');
      _chart = new Chart(ctx, {
        type: 'line',
        data: _chartData,
        options: chartOptions
      });
      ctx.style.display = 'block';
      showAnalytics();
    };

    //////////
    // Storage
    //////////
    const getConfig = () => {
      const config = localStorage.getItem("config");
      let settingsJson;
      if (config) {
        settingsJson = JSON.parse(config);
        return settingsJson;
      } else {
        _settings = {};
        setConfig();
      }
      return _settings;
    }

    const setConfig = () => {
      localStorage.setItem("config", JSON.stringify(_settings));
    }

    //////////
    // General UI/UX
    //////////
    const getRange = (dataset) => {
      const range = { start: null, end: null };
      dataset.forEach(k => {
        const start = k.data[k.data.length-1].last;
        const end = k.data[0].first;
        if (! range.start || new Date(start).getTime() < range.start)
            range.start = new Date(start).getTime();
        if (! range.end || new Date(end).getTime() > range.end)
          range.end = new Date(end).getTime();
      })
      return range;
    }

    const getFormattedDateTime = (timestamp) => {
      const date = new Date(timestamp);
      const formattedDate = date.toLocaleString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true,
      });
      return formattedDate;
    }

    const showRange = range => {
      const { start, end } = range;
      const rangeString = `${getFormattedDateTime(start)} - ${getFormattedDateTime(end)}`;
      document.getElementById('range').innerHTML = rangeString;
    }

    const onFileSelected = () => {
      const files = filesInput.files;
      if (files.length) {
        _uploadedFile = files[0];
        processFile();
      }
    };

    const uxOptions = () => {
      const granularity = document.getElementById('granularity').value;
      const ignoreGroupPosts = document.getElementById('ignoreGroupPosts').value === "yes";
      if (!_settings.options) _settings.options = {};
      _settings.options.granularity = granularity;
      _settings.ignoreGroupPosts = ignoreGroupPosts;
      setConfig();
      processFile();
    }

    const setUx = () => {
      if (_settings.options?.granularity)
        document.getElementById('granularity').value = _settings.options.granularity;
      if (_settings.options?.ignoreGroupPosts)
       document.getElementById('ignoreGroupPosts').value = _settings.options.ignoreGroupPosts;
    }
    ///////////
    // Analytics routines
    ///////////
    const setGoal = (granularity, label) => {
      const goal = window.prompt(`To what value should we set ${granularity} target for ${label}?`);
      if (!_settings.goals) _settings.goals = {};
      if (!_settings.goals[granularity]) _settings.goals[granularity] = {};
      _settings.goals[granularity][label] = goal;
      setConfig();
      showAnalytics();
    }

    const analyticsCalc = (label, dataset) => {
      const mean = (dataset.reduce((a,b)=>(a+b.y),0)/dataset.length).toFixed(1);
      const current = dataset[0].y;
      const dataset_past = dataset.slice(1);
      const dataset_now = dataset[0];
      const past_span_avg = (dataset_past.reduce((a,b)=>(a+b.span),0)/dataset_past.length / 86400000).toFixed(1);
      const current_span = (dataset_now.span / 86400000).toFixed(1);
      const elapsed = (current_span / past_span_avg).toFixed(3);
      const projected = elapsed !== '0.000' ? (current / elapsed).toFixed(1) : "0";
      const projectionAboveAvg = (parseFloat(projected) >= parseFloat(mean)); // yellow
      const currentAboveAvg = (parseFloat(current) >= parseFloat(mean)); // light green
      let goal = 0;
      try {
        if (_settings.goals[granularity][label]) {
          goal = _settings.goals[granularity][label];
        }
      } catch (e) {};
      const projectionAboveGoal = goal && (parseFloat(projected) >= parseFloat(goal)); // light green
      const currentAboveGoal = goal && (parseFloat(current) >= parseFloat(goal)); // dark green
      let progressColor = false;
      if (projectionAboveAvg) progressColor = 'projection-above-avg';
      if (currentAboveAvg) progressColor = 'current-above-avg'
      if (projectionAboveGoal) progressColor = 'projection-above-goal';
      if (currentAboveGoal) progressColor = 'current-above-goal';
      return { mean, current, elapsed, projected, progressColor, goal };
    };

    const showAnalytics = () => {
      document.getElementById('analytics').innerHTML =
        _chartData.datasets.map(ds => ({
        ...analyticsCalc(ds.label, ds.data),
        label:ds.label
      }))
        .map(d => (`
        <div class="hcard${d.progressColor ? ` ${d.progressColor}`:''}">
        <div class="label">${d.label}</div>
        <div class="mean"><label>Avg:</label><span class="value">${d.mean}</span></div>
        <div class="mean"><label>Current:</label><span class="value">${d.current}</span></div>
        <div class="projected"><label>Proj:</label><span class="value">${d.projected}</span></div>
        <div class="goal">${d.goal 
          ? `<label>Goal:</label><span class="value">${d.goal}</span>` 
          : `<a href="#" onClick="setGoal('${granularity}','${d.label}');">Set Goal</a>`
        }</div>
        </div>
        `))
        .join(" ")
      const range = getRange(_chartData.datasets);
      showRange(range);
    }

    const clearAnalytics = () => {
      document.getElementById('analytics').innerHTML = '';
    }


    ////////
    // Main
    ////////

    // Kicks off data processing
    const processFile = () => {
      clearAnalytics();
      if (_chart) {
        _chart.destroy();
      }
      if (_uploadedFile) {
        readZip(_uploadedFile, _settings.options.granularity)
          .then(transformFinal)
          .then(setChart);
      }
    };

    // Init
    (() => {
      _settings = getConfig();
      setUx();
    })()

  </script>

</body>
</html>
